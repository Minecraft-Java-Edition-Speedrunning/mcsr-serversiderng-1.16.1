package me.voidxwalker.serversiderng.mixin.rng_verification;

import me.voidxwalker.serversiderng.RNGHandler;
import me.voidxwalker.serversiderng.RNGSession;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.profiler.Profiler;
import net.minecraft.util.registry.RegistryKey;
import net.minecraft.world.MutableWorldProperties;
import net.minecraft.world.World;
import net.minecraft.world.dimension.DimensionType;
import net.minecraft.world.level.ServerWorldProperties;
import org.spongepowered.asm.mixin.Final;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

import java.util.Random;
import java.util.function.BooleanSupplier;
import java.util.function.Supplier;

@Mixin(ServerWorld.class)
public abstract class ServerWorldMixin extends World {
    
    @Shadow @Final private ServerWorldProperties worldProperties;

    @Unique
    private Boolean serverSideRNG_duringThunder;

    protected ServerWorldMixin(
            MutableWorldProperties mutableWorldProperties,
            RegistryKey<World> registryKey,
            RegistryKey<DimensionType> registryKey2,
            DimensionType dimensionType,
            Supplier<Profiler> profiler,
            boolean bl,
            boolean bl2,
            long l
    ) {
        super(mutableWorldProperties, registryKey, registryKey2, dimensionType, profiler, bl, bl2, l);
    }
    /**
     * Uses the from {@link RNGHandler#getRngValue(RNGHandler.RNGTypes)} obtained random {@code Long}, that has been generated by the {@code Verification-Server}, as a seed for the {@link RNGHandler.RNGTypes#THUNDER} RNG.
     * @see RNGHandler#getRngValue(RNGHandler.RNGTypes)
     * @author Void_X_Walker
     */
    @Inject(method = "tick", at = @At(value = "INVOKE", target = "Lnet/minecraft/world/level/ServerWorldProperties;setRaining(Z)V"))
    public void modifyThunderRandom(CallbackInfo ci) {
        RNGSession.getRngContext(RNGHandler.RNGTypes.THUNDER)
            .filter((it) -> serverSideRNG_duringThunder != null)
            .map(Supplier::get)
            .map(Random::new)
            .ifPresent((random -> worldProperties.setThunderTime(
                serverSideRNG_duringThunder ? random.nextInt(12000) + 3600
                    : random.nextInt(168000) + 12000
            )));
        duringThunder = null;
    }
    /**
     * Predicts how {@link ServerWorld#tick(BooleanSupplier)} will modify the thunder property and sets {@link ServerWorldMixin#serverSideRNG_duringThunder} accordingly: {@code null} if the thunder won't be verified at all and {@code true} / {@code false} depending on if the thunder modification occurred during thunder.
     * @author Void_X_Walker
     */
    @Inject(method = "tick", at = @At(value = "INVOKE", target = "Lnet/minecraft/world/MutableWorldProperties;isRaining()Z"))
    public void getRandom(BooleanSupplier shouldKeepTicking, CallbackInfo ci) {
        if (!RNGSession.inSession()) {
            serverSideRNG_duringThunder = null;
            return;
        }
        int i = worldProperties.getClearWeatherTime();
        int j = worldProperties.getThunderTime();
        boolean bl2 = properties.isThundering();
        if (i <= 0 && j <= 0) {
            serverSideRNG_duringThunder = bl2;
        }
    }
}
